# =============================================================================
# Composite Build Specification v1.0
# =============================================================================
#
# A build-system-agnostic specification for declaring cross-repository
# composite builds. This file is the single source of truth that drives
# both local development setup and CI pipeline generation.
#
# Two complementary files form the complete picture:
#
#   PRODUCERS.yaml   — lives in the CONSUMER repo
#                     declares which producers this project depends on
#                     drives CI to clone producers and generate build config
#
#   CONSUMERS.yaml  — lives in the PRODUCER repo
#                     declares which consumers depend on this project
#                     drives CI to test consumers on producer changes
#
# Together they create a bidirectional dependency graph:
#
#   Producer repo (CONSUMERS.yaml)        Consumer repo (PRODUCERS.yaml)
#   ┌──────────────────────────┐          ┌──────────────────────────┐
#   │ "These repos consume me" │ ◄──────► │ "I depend on these repos"│
#   └──────────────────────────┘          └──────────────────────────┘
#
# Supported integration types: Bazel (module), Source (copy), Gradle, Maven
# =============================================================================

schema_version: "1.0"

# =============================================================================
# PART 1: PRODUCERS.yaml (lives in consumer repo)
# =============================================================================
# Declares upstream dependencies. CI reads this to clone producers and
# generate the composite build configuration on the fly.
# =============================================================================

consumer:
  name: bazel-app
  repository: https://github.com/pravasna30-dev/bazel-app.git
  build_system: bazel            # bazel | gradle | maven
  language: java
  language_version: "21"

producers:
  - name: composite-monorepo
    repository: https://github.com/pravasna30-dev/bazel-monorepo.git
    ref: main                    # branch, tag, or commit SHA
    path: ../bazel-monorepo      # clone location relative to consumer root

    # --- Build system wiring (one per supported build system) ---

    bazel:
      module_name: composite-monorepo
      module_version: "1.0.0"
      targets:
        - "//low-level-1:LowLevelOne"
      module_bazel_snippet: |
        bazel_dep(name = "composite-monorepo", version = "1.0.0")
        local_path_override(
            module_name = "composite-monorepo",
            path = "../bazel-monorepo",
        )
      build_deps:
        - "@composite-monorepo//low-level-1:LowLevelOne"

    gradle:
      group: com.acme.arc.dep
      artifact: low-level-1
      version: "1.0.0"
      settings_snippet: |
        includeBuild("../bazel-monorepo") {
            dependencySubstitution {
                substitute(module("com.acme.arc.dep:low-level-1")).using(project(":low-level-1"))
            }
        }
      publish_command: "./gradlew publishToMavenLocal -Pversion=1.0.0"
      dependency_snippet: |
        implementation("com.acme.arc.dep:low-level-1:1.0.0")

    maven:
      group_id: com.acme.arc.dep
      artifact_id: low-level-1
      version: "1.0.0"
      install_command: "mvn install -DskipTests"
      pom_snippet: |
        <dependency>
            <groupId>com.acme.arc.dep</groupId>
            <artifactId>low-level-1</artifactId>
            <version>1.0.0</version>
        </dependency>

    verification:
      imports:
        - class: com.acme.arc.dep.test.LowOneMain
          call: LowOneMain.say()
      expected_output: "Low-level-1"

# =============================================================================
# PART 2: CONSUMERS.yaml (lives in producer repo)
# =============================================================================
# Declares downstream consumers. When a producer changes, CI reads this
# to clone each consumer, wire up the composite build, and run their tests
# against the new producer code — catching breaking changes before merge.
#
# Example: this would live in bazel-monorepo/CONSUMERS.yaml
# =============================================================================

# schema_version: "1.0"
#
# producer:
#   name: composite-monorepo
#   repository: https://github.com/pravasna30-dev/bazel-monorepo.git
#   build_system: bazel
#
# consumers:
#   - name: bazel-app
#     repository: https://github.com/pravasna30-dev/bazel-app.git
#     ref: main
#     build_system: bazel
#     modules:
#       - "//low-level-1:LowLevelOne"
#     criticality: critical          # critical | important | optional
#     contact: pravasna30@gmail.com
#     ci:
#       trigger_on_update: true
#       test_command: "bazel test //..."

# =============================================================================
# PART 3: Wiring Instructions
# =============================================================================
# Step-by-step instructions for each build system. CI workflows automate
# these steps; developers can follow them for local setup.
# =============================================================================

wiring:

  # ---------------------------------------------------------------------------
  # Bazel
  # ---------------------------------------------------------------------------
  bazel:
    description: >
      Bazel uses Bzlmod (MODULE.bazel) with local_path_override to resolve
      external modules from a local directory. Bazel builds the producer
      from source — no pre-built artifacts needed.

    local:
      steps:
        - description: Clone producer as sibling directory
          command: "git clone {producer.repository} {producer.path}"
        - description: Append to MODULE.bazel
          file: MODULE.bazel
          action: append
          content: "{producer.bazel.module_bazel_snippet}"
        - description: Add targets to BUILD deps
          file: BUILD
          action: inject_deps
          content: "{producer.bazel.build_deps}"
        - description: Import and call in source code
          file: "src/main/java/**/*.java"
          action: add_imports_and_calls
          content: "{producer.verification.imports}"
      verify: "bazel run //:app"

    ci:
      consumer_side:
        description: >
          Consumer CI: reads PRODUCERS.yaml, clones producers, generates
          MODULE.bazel + BUILD + source code, builds and runs.
        steps:
          - description: Checkout consumer
            action: "actions/checkout@v4"
          - description: Clone producer at specified ref
            command: "git clone --branch {producer.ref} --single-branch --depth 1 {producer.repository} {producer.path}"
          - description: Generate MODULE.bazel
            file: MODULE.bazel
            action: append
            content: "{producer.bazel.module_bazel_snippet}"
          - description: Generate BUILD with deps
            file: BUILD
            action: rewrite_with_deps
            content: "{producer.bazel.build_deps}"
          - description: Generate source with imports and calls
            file: "src/main/java/com/example/app/App.java"
            action: rewrite_with_imports
            content: "{producer.verification.imports}"
        verify: "bazel build //:app && bazel run //:app"

      producer_side:
        description: >
          Producer CI: reads CONSUMERS.yaml, clones each consumer, generates
          their build config to point at the PR branch, runs consumer tests.
          This catches breaking changes before the producer PR is merged.
        steps:
          - description: Checkout producer (PR branch)
            action: "actions/checkout@v4"
          - description: Parse CONSUMERS.yaml and clone each consumer
            command: |
              for consumer in $(yq '.consumers[].repository' CONSUMERS.yaml); do
                name=$(basename "$consumer" .git)
                ref=$(yq ".consumers[] | select(.repository == \"$consumer\") | .ref" CONSUMERS.yaml)
                git clone --branch "$ref" --single-branch --depth 1 "$consumer" "../$name"
              done
          - description: Generate each consumer's build config to use local producer
            action: generate_composite_config_per_consumer
          - description: Run each consumer's tests
            command: |
              for consumer in $(yq '.consumers[].name' CONSUMERS.yaml); do
                cd "../$consumer"
                bazel test //...
              done
        verify: "All consumer tests pass"

  # ---------------------------------------------------------------------------
  # Source (native integration)
  # ---------------------------------------------------------------------------
  source:
    description: >
      Source integration copies Java source files from the producer into a
      local Bazel package within the consumer repo. CI generates a java_library
      BUILD file so the sources are built natively by Bazel — no external
      build system needed. This is ideal for integrating non-Bazel producers
      (Gradle, Maven) into a Bazel consumer without requiring their build tool.

    local:
      steps:
        - description: Clone producer as sibling directory
          command: "git clone {producer.repository} {producer.path}"
        - description: Copy sources into local Bazel package
          command: |
            mkdir -p {producer.package_name}/src/main/java
            cp -r {producer.path}/{producer.source_root}/* {producer.package_name}/src/main/java/
        - description: Generate java_library BUILD file
          file: "{producer.package_name}/BUILD"
          action: create
          content: |
            load("@rules_java//java:defs.bzl", "java_library")
            java_library(
                name = "library",
                srcs = glob(["src/main/java/**/*.java"]),
                visibility = ["//visibility:public"],
            )
        - description: Add target to BUILD deps
          file: BUILD
          action: inject_deps
          content: "{producer.target}"
        - description: Import and call in source code
          file: "src/main/java/**/*.java"
          action: add_imports_and_calls
          content: "{producer.imports}"
      verify: "bazel run //:app"

    ci:
      consumer_side:
        description: >
          Consumer CI: reads PRODUCERS.yaml, clones producer, copies sources
          into a local Bazel package, generates java_library BUILD, builds
          and runs.
        steps:
          - description: Checkout consumer
            action: "actions/checkout@v4"
          - description: Clone producer at specified ref
            command: "git clone --branch {producer.ref} --single-branch --depth 1 {producer.repository} {producer.path}"
          - description: Copy sources into local Bazel package
            command: |
              mkdir -p {producer.package_name}/src/main/java
              cp -r {producer.path}/{producer.source_root}/* {producer.package_name}/src/main/java/
          - description: Generate java_library BUILD
            file: "{producer.package_name}/BUILD"
            action: create
            content: |
              load("@rules_java//java:defs.bzl", "java_library")
              java_library(name = "library", srcs = glob(["src/main/java/**/*.java"]), visibility = ["//visibility:public"])
          - description: Generate BUILD with deps
            file: BUILD
            action: rewrite_with_deps
            content: "{producer.target}"
          - description: Generate source with imports and calls
            file: "src/main/java/com/example/app/App.java"
            action: rewrite_with_imports
            content: "{producer.imports}"
        verify: "bazel build //:app && bazel run //:app"

  # ---------------------------------------------------------------------------
  # Gradle
  # ---------------------------------------------------------------------------
  gradle:
    description: >
      Gradle uses composite builds (includeBuild + dependencySubstitution)
      for local source integration, or Maven Local publishing for artifact-
      based integration. Composite build is preferred — changes are picked
      up immediately without a publish step.

    local:
      composite_build:
        steps:
          - description: Clone producer as sibling directory
            command: "git clone {producer.repository} {producer.path}"
          - description: Add includeBuild to settings.gradle.kts
            file: settings.gradle.kts
            action: append
            content: "{producer.gradle.settings_snippet}"
        verify: "./gradlew build"

      maven_local:
        steps:
          - description: Clone producer as sibling directory
            command: "git clone {producer.repository} {producer.path}"
          - description: Publish producer to Maven Local
            command: "cd {producer.path} && {producer.gradle.publish_command}"
          - description: Add dependency to build.gradle.kts
            file: build.gradle.kts
            action: add_dependency
            content: "{producer.gradle.dependency_snippet}"
        verify: "./gradlew build"

    ci:
      consumer_side:
        description: >
          Consumer CI: reads PRODUCERS.yaml, clones producers, generates
          settings.gradle.kts with includeBuild + dependencySubstitution.
        steps:
          - description: Checkout consumer
            action: "actions/checkout@v4"
          - description: Clone producer at specified ref
            command: "git clone --branch {producer.ref} --single-branch --depth 1 {producer.repository} {producer.path}"
          - description: Generate settings.gradle.kts with composite build
            file: settings.gradle.kts
            action: append
            content: "{producer.gradle.settings_snippet}"
        verify: "./gradlew build && ./gradlew test"

      producer_side:
        description: >
          Producer CI: reads CONSUMERS.yaml, clones each consumer, generates
          their settings.gradle.kts to use local source via composite build.
        steps:
          - description: Checkout producer (PR branch)
            action: "actions/checkout@v4"
          - description: Parse CONSUMERS.yaml and clone each consumer
            command: |
              for consumer in $(yq '.consumers[].repository' CONSUMERS.yaml); do
                name=$(basename "$consumer" .git)
                git clone "$consumer" "../$name"
              done
          - description: Generate composite build in each consumer
            command: |
              for name in $(yq '.consumers[].name' CONSUMERS.yaml); do
                cat >> "../$name/settings.gradle.kts" << EOF
                includeBuild("../$(yq '.producer.name' CONSUMERS.yaml)") {
                    dependencySubstitution {
                        substitute(module("{group}:{artifact}")).using(project(":"))
                    }
                }
              EOF
              done
          - description: Run each consumer's tests
            command: |
              for name in $(yq '.consumers[].name' CONSUMERS.yaml); do
                cd "../$name" && ./gradlew build
              done
        verify: "All consumer builds and tests pass"

  # ---------------------------------------------------------------------------
  # Maven
  # ---------------------------------------------------------------------------
  maven:
    description: >
      Maven uses local repository installation (mvn install) to make
      producer artifacts available, then references them via standard
      GAV coordinates in pom.xml. There is no composite build equivalent
      in Maven — artifacts must be installed first.

    local:
      steps:
        - description: Clone producer as sibling directory
          command: "git clone {producer.repository} {producer.path}"
        - description: Install producer to local Maven repository
          command: "cd {producer.path} && {producer.maven.install_command}"
        - description: Add dependency to pom.xml
          file: pom.xml
          action: add_dependency
          content: "{producer.maven.pom_snippet}"
      verify: "mvn compile exec:java -Dexec.mainClass=com.example.app.App"

    ci:
      consumer_side:
        description: >
          Consumer CI: reads PRODUCERS.yaml, clones producers, runs mvn install,
          injects dependency into pom.xml.
        steps:
          - description: Checkout consumer
            action: "actions/checkout@v4"
          - description: Clone producer at specified ref
            command: "git clone --branch {producer.ref} --single-branch --depth 1 {producer.repository} {producer.path}"
          - description: Install producer to local Maven repository
            command: "cd {producer.path} && {producer.maven.install_command}"
          - description: Inject dependency into pom.xml
            file: pom.xml
            action: add_dependency
            content: "{producer.maven.pom_snippet}"
        verify: "mvn clean verify"

      producer_side:
        description: >
          Producer CI: reads CONSUMERS.yaml, installs producer locally,
          clones each consumer, runs their tests against the new version.
        steps:
          - description: Checkout producer (PR branch)
            action: "actions/checkout@v4"
          - description: Install producer to local Maven repository
            command: "mvn install -DskipTests"
          - description: Parse CONSUMERS.yaml and clone each consumer
            command: |
              for consumer in $(yq '.consumers[].repository' CONSUMERS.yaml); do
                name=$(basename "$consumer" .git)
                git clone "$consumer" "../$name"
              done
          - description: Run each consumer's tests
            command: |
              for name in $(yq '.consumers[].name' CONSUMERS.yaml); do
                cd "../$name" && mvn clean verify
              done
        verify: "All consumer builds and tests pass"

# =============================================================================
# Quick Reference
# =============================================================================
#
# File Placement:
# ┌───────────────────────────────────────────────────────────────────────────┐
# │  PRODUCERS.yaml    → lives in CONSUMER repo (who do I depend on?)        │
# │  CONSUMERS.yaml   → lives in PRODUCER repo (who depends on me?)         │
# │  composite-build-spec.yaml → reference spec (this file)                 │
# └───────────────────────────────────────────────────────────────────────────┘
#
# CI Flow — Consumer Side (triggered on consumer changes):
# ┌─────────────────────────────────────────────────────────────────────────┐
# │  1. Read PRODUCERS.yaml                                                 │
# │  2. Clone each producer at specified ref                               │
# │  3. Generate build config (MODULE.bazel / settings.gradle / pom.xml)   │
# │  4. Generate source code (inject imports and calls)                    │
# │  5. Build and run to verify integration                                │
# └─────────────────────────────────────────────────────────────────────────┘
#
# CI Flow — Producer Side (triggered on producer PRs):
# ┌─────────────────────────────────────────────────────────────────────────┐
# │  1. Read CONSUMERS.yaml                                                │
# │  2. Clone each consumer at specified ref                               │
# │  3. Wire each consumer to use local producer (composite build)         │
# │  4. Run each consumer's tests against new producer code                │
# │  5. Block PR if any consumer breaks                                    │
# └─────────────────────────────────────────────────────────────────────────┘
#
# Integration Type Comparison:
# ┌─────────────────────┬────────────────────────┬─────────────────────────┬──────────────────────────────┬──────────────────────────┐
# │ Aspect              │ Bazel (module)          │ Source (copy)           │ Gradle                       │ Maven                    │
# ├─────────────────────┼────────────────────────┼─────────────────────────┼──────────────────────────────┼──────────────────────────┤
# │ Config file         │ MODULE.bazel + BUILD   │ {pkg}/BUILD             │ settings.gradle.kts          │ pom.xml                  │
# │ Local wiring        │ local_path_override    │ cp sources + java_lib   │ includeBuild + depSubst      │ mvn install + GAV in pom │
# │ CI wiring           │ Generate MODULE + BUILD│ cp sources + gen BUILD  │ Generate settings.gradle.kts │ mvn install + inject pom │
# │ Builds from source? │ Yes (external module)  │ Yes (native package)    │ Yes (composite) / No (maven) │ No (requires install)    │
# │ Publish step needed?│ No                     │ No                      │ No (composite) / Yes (maven) │ Yes (mvn install)        │
# │ Dep format          │ @module//pkg:target    │ //pkg:target            │ group:artifact:version       │ groupId:artifactId:ver   │
# │ Producer build sys  │ Bazel                  │ Any (Gradle, Maven...) │ Gradle                       │ Maven                    │
# │ Transitive deps     │ Explicit in BUILD      │ Explicit in BUILD       │ Automatic                    │ Automatic                │
# └─────────────────────┴────────────────────────┴─────────────────────────┴──────────────────────────────┴──────────────────────────┘
# =============================================================================
